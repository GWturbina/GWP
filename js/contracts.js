/* jshint esversion: 8 */
/* global CONFIG, web3Manager, ethers, Utils */

/**
 * GlobalWay Contracts Manager - –ò–°–ü–†–ê–í–õ–ï–ù–û
 * –í–µ—Ä—Å–∏—è: 2.1 - –ò—Å–ø—Ä–∞–≤–ª–µ–Ω—ã –Ω–∞–∑–≤–∞–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–π –ø–æ ABI
 */

class ContractsManager {
  constructor() {
    this.contracts = {};
    this.initialized = false;
  }

  /**
   * –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –≤—Å—ñ—Ö –∫–æ–Ω—Ç—Ä–∞–∫—Ç—ñ–≤
   */
  async init() {
    if (!web3Manager.connected) {
      throw new Error('Wallet not connected');
    }

    if (this.initialized) {
      console.log('‚ö†Ô∏è Contracts already initialized');
      return;
    }

    console.log('üìÑ Initializing contracts...');

    try {
      // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑—É–≤–∞—Ç–∏ –∫–æ–∂–µ–Ω –∫–æ–Ω—Ç—Ä–∞–∫—Ç –∑ –π–æ–≥–æ ABI
      await this.initializeContract('gwtToken', 'GWTToken');
      await this.initializeContract('globalWay', 'GlobalWay');
      await this.initializeContract('marketing', 'Marketing');
      await this.initializeContract('leaderPool', 'LeaderPool');
      await this.initializeContract('investment', 'Investment');
      await this.initializeContract('quarterly', 'Quarterly');
      await this.initializeContract('techAccounts', 'TechAccounts');
      await this.initializeContract('bridge', 'Bridge');
      await this.initializeContract('stats', 'Stats');
      await this.initializeContract('governance', 'Governance');

      this.initialized = true;
      console.log('‚úÖ All 10 contracts initialized successfully');

    } catch (error) {
      console.error('‚ùå Contracts initialization failed:', error);
      throw error;
    }
  }

  /**
   * –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –æ–∫—Ä–µ–º–æ–≥–æ –∫–æ–Ω—Ç—Ä–∞–∫—Ç—É
   */
  async initializeContract(key, name) {
    try {
      const address = CONFIG.CONTRACTS[name] || CONFIG.CONTRACTS[key];
      
      if (!address) {
        throw new Error(`Address not found for ${name}`);
      }

      if (!ethers.utils.isAddress(address)) {
        throw new Error(`Invalid address for ${name}: ${address}`);
      }

      // –ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ ABI –∑ JSON —Ñ–∞–π–ª—É
      const abiPath = `./contracts/abis/GlobalWay${name === 'GlobalWay' ? '' : name}.json`;
      const response = await fetch(abiPath);
      const abiData = await response.json();

      this.contracts[key] = new ethers.Contract(
        address,
        abiData.abi,
        web3Manager.signer
      );

      console.log(`‚úÖ ${name} initialized at ${address}`);

    } catch (error) {
      console.error(`‚ùå Failed to initialize ${name}:`, error);
      throw error;
    }
  }

  // ==========================================
  // GLOBALWAY - –ì–æ–ª–æ–≤–Ω–∏–π –∫–æ–Ω—Ç—Ä–∞–∫—Ç
  // ==========================================

  /**
   * –û—Ç—Ä–∏–º–∞—Ç–∏ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
   */
  async getUserInfo(address) {
    try {
      const user = await this.contracts.globalWay.users(address);
      
      return {
        id: user.id || '',
        sponsorId: user.sponsorId || '',
        refAddress: user.refAddress || ethers.constants.AddressZero,
        registrationTime: user.registrationTime ? user.registrationTime.toNumber() : 0,
        rankLevel: Number(user.rankLevel) || 0,
        activeLevel: Number(user.activeLevel) || 0,
        partnersCount: Number(user.partnersCount) || 0,
        isActive: Boolean(user.isActive),
        isBlocked: Boolean(user.isBlocked)
      };
    } catch (error) {
      console.error('getUserInfo error:', error);
      return {
        id: '',
        sponsorId: '',
        refAddress: ethers.constants.AddressZero,
        registrationTime: 0,
        rankLevel: 0,
        activeLevel: 0,
        partnersCount: 0,
        isActive: false,
        isBlocked: false
      };
    }
  }

  /**
   * –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —á–∏ –∑–∞—Ä–µ—î—Å—Ç—Ä–æ–≤–∞–Ω–∏–π –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á
   */
  async isUserRegistered(address) {
    try {
      const userInfo = await this.getUserInfo(address);
      return userInfo.id !== '' && userInfo.registrationTime > 0;
    } catch (error) {
      console.error('isUserRegistered error:', error);
      return false;
    }
  }

  /**
   * –û—Ç—Ä–∏–º–∞—Ç–∏ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ —Ä—ñ–≤–µ–Ω—å –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
   */
  async getUserLevel(address, level) {
    try {
      const levelInfo = await this.contracts.globalWay.getUserLevelInfo(address, level);
      
      return {
        isActive: Boolean(levelInfo.isActive),
        activationTime: levelInfo.activationTime ? levelInfo.activationTime.toNumber() : 0,
        reactivations: Number(levelInfo.reactivations) || 0,
        partnersCount: Number(levelInfo.partnersCount) || 0,
        cyclesCount: Number(levelInfo.cyclesCount) || 0
      };
    } catch (error) {
      console.error('getUserLevel error:', error);
      return {
        isActive: false,
        activationTime: 0,
        reactivations: 0,
        partnersCount: 0,
        cyclesCount: 0
      };
    }
  }

  /**
   * –†–µ—î—Å—Ç—Ä–∞—Ü—ñ—è –Ω–æ–≤–æ–≥–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
   */
  async register(refAddress) {
    try {
      const price = ethers.utils.parseEther(CONFIG.LEVEL_PRICES[0]);
      
      console.log('üìù Registering user with referrer:', refAddress);
      console.log('üí∞ Payment:', CONFIG.LEVEL_PRICES[0], 'BNB');
      
      const tx = await this.contracts.globalWay.register(refAddress, {
        value: price,
        gasLimit: CONFIG.GAS_LIMITS.register
      });
      
      console.log('üì§ Transaction sent:', tx.hash);
      const receipt = await tx.wait();
      console.log('‚úÖ Registration successful');
      
      return receipt;
    } catch (error) {
      console.error('‚ùå Registration failed:', error);
      throw error;
    }
  }

  /**
   * –ö—É–ø—ñ–≤–ª—è –æ–∫—Ä–µ–º–æ–≥–æ —Ä—ñ–≤–Ω—è
   * üî• –í–ò–ü–†–ê–í–õ–ï–ù–û: buyLevel() –∑–∞–º—ñ—Å—Ç—å activateLevel()
   */
  async buyLevel(level) {
    try {
      const price = ethers.utils.parseEther(CONFIG.LEVEL_PRICES[level - 1]);
      
      console.log(`üìù Buying Level ${level}`);
      console.log('üí∞ Payment:', CONFIG.LEVEL_PRICES[level - 1], 'BNB');
      
      const tx = await this.contracts.globalWay.buyLevel(level, {
        value: price,
        gasLimit: CONFIG.GAS_LIMITS.buyLevel
      });
      
      console.log('üì§ Transaction sent:', tx.hash);
      const receipt = await tx.wait();
      console.log('‚úÖ Level activated');
      
      return receipt;
    } catch (error) {
      console.error('‚ùå Buy level failed:', error);
      throw error;
    }
  }

  /**
   * –ü–∞–∫–µ—Ç–Ω–∞ –∫—É–ø—ñ–≤–ª—è —Ä—ñ–≤–Ω—ñ–≤
   * üî• –í–ò–ü–†–ê–í–õ–ï–ù–û: buyBulkLevels() –∑–∞–º—ñ—Å—Ç—å activateBulkLevels()
   */
  async buyBulkLevels(upToLevel) {
    try {
      let totalPrice = ethers.BigNumber.from(0);
      for (let i = 0; i < upToLevel; i++) {
        totalPrice = totalPrice.add(ethers.utils.parseEther(CONFIG.LEVEL_PRICES[i]));
      }
      
      console.log(`üìù Buying Levels 1-${upToLevel}`);
      console.log('üí∞ Total payment:', ethers.utils.formatEther(totalPrice), 'BNB');
      
      const tx = await this.contracts.globalWay.buyBulkLevels(upToLevel, {
        value: totalPrice,
        gasLimit: CONFIG.GAS_LIMITS.buyBulkLevels
      });
      
      console.log('üì§ Transaction sent:', tx.hash);
      const receipt = await tx.wait();
      console.log('‚úÖ Bulk levels activated');
      
      return receipt;
    } catch (error) {
      console.error('‚ùå Bulk buy failed:', error);
      throw error;
    }
  }

  /**
   * –û—Ç—Ä–∏–º–∞—Ç–∏ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –º–∞—Ç—Ä–∏—Ü—é
   */
  async getMatrixInfo(address, level) {
    try {
      return await this.contracts.globalWay.getMatrixInfo(address, level);
    } catch (error) {
      console.error('getMatrixInfo error:', error);
      return null;
    }
  }

  /**
   * –û—Ç—Ä–∏–º–∞—Ç–∏ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ —Ä–∞–Ω–≥
   */
  async getRankInfo(address) {
    try {
      const userInfo = await this.getUserInfo(address);
      return {
        currentRank: userInfo.rankLevel,
        rankName: CONFIG.RANKS[userInfo.rankLevel] || 'None'
      };
    } catch (error) {
      console.error('getRankInfo error:', error);
      return {
        currentRank: 0,
        rankName: 'None'
      };
    }
  }

  // ==========================================
  // GWTTOKEN - –¢–æ–∫–µ–Ω
  // ==========================================

  /**
   * –û—Ç—Ä–∏–º–∞—Ç–∏ –±–∞–ª–∞–Ω—Å —Ç–æ–∫–µ–Ω—ñ–≤
   */
  async getTokenBalance(address) {
    try {
      return await this.contracts.gwtToken.balanceOf(address);
    } catch (error) {
      console.error('getTokenBalance error:', error);
      return ethers.BigNumber.from(0);
    }
  }

  /**
   * –û—Ç—Ä–∏–º–∞—Ç–∏ –ø–æ—Ç–æ—á–Ω—É —Ü—ñ–Ω—É —Ç–æ–∫–µ–Ω—É
   */
  async getTokenPrice() {
    try {
      return await this.contracts.gwtToken.getCurrentPrice();
    } catch (error) {
      console.error('getTokenPrice error:', error);
      return ethers.BigNumber.from(0);
    }
  }

  /**
   * –ö—É–ø–∏—Ç–∏ —Ç–æ–∫–µ–Ω–∏
   */
  async buyTokens(amount) {
    try {
      const tx = await this.contracts.gwtToken.buy(amount, {
        gasLimit: CONFIG.GAS_LIMITS.tokenBuy
      });
      
      const receipt = await tx.wait();
      return receipt;
    } catch (error) {
      console.error('buyTokens error:', error);
      throw error;
    }
  }

  /**
   * –ü—Ä–æ–¥–∞—Ç–∏ —Ç–æ–∫–µ–Ω–∏
   */
  async sellTokens(amount) {
    try {
      const tx = await this.contracts.gwtToken.sell(amount, {
        gasLimit: CONFIG.GAS_LIMITS.tokenSell
      });
      
      const receipt = await tx.wait();
      return receipt;
    } catch (error) {
      console.error('sellTokens error:', error);
      throw error;
    }
  }

  // ==========================================
  // MARKETING - –†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞ —Å–∏—Å—Ç–µ–º–∞
  // ==========================================

  /**
   * –í–∏–≤–µ—Å—Ç–∏ –∫–æ—à—Ç–∏ –∑ Marketing –∫–æ–Ω—Ç—Ä–∞–∫—Ç—É
   */
  async withdrawMarketing() {
    try {
      const tx = await this.contracts.marketing.withdraw({
        gasLimit: CONFIG.GAS_LIMITS.withdraw
      });
      
      const receipt = await tx.wait();
      return receipt;
    } catch (error) {
      console.error('withdrawMarketing error:', error);
      throw error;
    }
  }

  /**
   * –û—Ç—Ä–∏–º–∞—Ç–∏ —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–∏–π –±–∞–ª–∞–Ω—Å
   */
  async getReferralBalance(address) {
    try {
      return await this.contracts.marketing.referralBalances(address);
    } catch (error) {
      console.error('getReferralBalance error:', error);
      return ethers.BigNumber.from(0);
    }
  }

  /**
   * –û—Ç—Ä–∏–º–∞—Ç–∏ –º–∞—Ç—Ä–∏—á–Ω–∏–π –±–∞–ª–∞–Ω—Å
   */
  async getMatrixBalance(address) {
    try {
      return await this.contracts.marketing.matrixBalances(address);
    } catch (error) {
      console.error('getMatrixBalance error:', error);
      return ethers.BigNumber.from(0);
    }
  }

  // ==========================================
  // LEADERPOOL - –ü—É–ª –ª—ñ–¥–µ—Ä—ñ–≤
  // ==========================================

  /**
   * –í–∏–≤–µ—Å—Ç–∏ –∫–æ—à—Ç–∏ –∑ Leader Pool
   */
  async withdrawLeaderPool() {
    try {
      const tx = await this.contracts.leaderPool.withdraw({
        gasLimit: CONFIG.GAS_LIMITS.withdraw
      });
      
      const receipt = await tx.wait();
      return receipt;
    } catch (error) {
      console.error('withdrawLeaderPool error:', error);
      throw error;
    }
  }

  /**
   * –û—Ç—Ä–∏–º–∞—Ç–∏ –±–∞–ª–∞–Ω—Å –≤ Leader Pool
   */
  async getLeaderBalance(address) {
    try {
      return await this.contracts.leaderPool.balances(address);
    } catch (error) {
      console.error('getLeaderBalance error:', error);
      return ethers.BigNumber.from(0);
    }
  }

  // ==========================================
  // INVESTMENT - –Ü–Ω–≤–µ—Å—Ç–∏—Ü—ñ–π–Ω–∏–π –ø—É–ª
  // ==========================================

  /**
   * –í–∏–≤–µ—Å—Ç–∏ –∫–æ—à—Ç–∏ –∑ Investment Pool
   */
  async withdrawInvestment() {
    try {
      const tx = await this.contracts.investment.withdraw({
        gasLimit: CONFIG.GAS_LIMITS.withdraw
      });
      
      const receipt = await tx.wait();
      return receipt;
    } catch (error) {
      console.error('withdrawInvestment error:', error);
      throw error;
    }
  }

  /**
   * –û—Ç—Ä–∏–º–∞—Ç–∏ —ñ–Ω–≤–µ—Å—Ç–∏—Ü—ñ–π–Ω–∏–π –±–∞–ª–∞–Ω—Å
   */
  async getInvestmentBalance(address) {
    try {
      const investor = await this.contracts.investment.investors(address);
      return investor.pendingReward || ethers.BigNumber.from(0);
    } catch (error) {
      console.error('getInvestmentBalance error:', error);
      return ethers.BigNumber.from(0);
    }
  }

  // ==========================================
  // QUARTERLY - –ö–≤–∞—Ä—Ç–∞–ª—å–Ω–∞ –∞–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å
  // ==========================================

  /**
   * –û–ø–ª–∞—Ç–∏—Ç–∏ –∫–≤–∞—Ä—Ç–∞–ª—å–Ω—É –∞–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å
   */
  async payQuarterly(charityRecipient = null) {
    try {
      const cost = ethers.utils.parseEther(CONFIG.QUARTERLY_COST);
      
      console.log('üìù Paying quarterly activity');
      console.log('üí∞ Payment:', CONFIG.QUARTERLY_COST, 'BNB');
      
      let tx;
      if (charityRecipient) {
        tx = await this.contracts.quarterly.payQuarterlyActivity(charityRecipient, {
          value: cost,
          gasLimit: CONFIG.GAS_LIMITS.payQuarterly
        });
      } else {
        tx = await this.contracts.quarterly.payQuarterlyActivityRegular({
          value: cost,
          gasLimit: CONFIG.GAS_LIMITS.payQuarterly
        });
      }
      
      console.log('üì§ Transaction sent:', tx.hash);
      const receipt = await tx.wait();
      console.log('‚úÖ Quarterly payment successful');
      
      return receipt;
    } catch (error) {
      console.error('‚ùå Quarterly payment failed:', error);
      throw error;
    }
  }

  /**
   * –û—Ç—Ä–∏–º–∞—Ç–∏ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –∫–≤–∞—Ä—Ç–∞–ª—å–Ω—É –∞–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å
   */
  async getQuarterlyInfo(address) {
    try {
      const info = await this.contracts.quarterly.getUserQuarterlyInfo(address);
      
      return {
        lastPayment: info.lastPayment ? info.lastPayment.toNumber() : 0,
        quarterCount: Number(info.quarterCount) || 0,
        charityAccount: info.charityAccount || ethers.constants.AddressZero,
        techAccount1: info.techAccount1 || ethers.constants.AddressZero,
        techAccount2: info.techAccount2 || ethers.constants.AddressZero,
        nextPaymentTime: info.nextPaymentTime ? info.nextPaymentTime.toNumber() : 0
      };
    } catch (error) {
      console.error('getQuarterlyInfo error:', error);
      return {
        lastPayment: 0,
        quarterCount: 0,
        charityAccount: ethers.constants.AddressZero,
        techAccount1: ethers.constants.AddressZero,
        techAccount2: ethers.constants.AddressZero,
        nextPaymentTime: 0
      };
    }
  }

  /**
   * –í–∏–≤–µ—Å—Ç–∏ upline –±–æ–Ω—É—Å–∏
   */
  async withdrawUplineBonus() {
    try {
      const tx = await this.contracts.quarterly.withdrawUplineBonus({
        gasLimit: CONFIG.GAS_LIMITS.withdraw
      });
      
      const receipt = await tx.wait();
      return receipt;
    } catch (error) {
      console.error('withdrawUplineBonus error:', error);
      throw error;
    }
  }

  // ==========================================
  // STATS - –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
  // ==========================================

  /**
   * –û—Ç—Ä–∏–º–∞—Ç–∏ –ø–æ–≤–Ω—É —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
   */
  async getUserFullStats(address) {
    try {
      const stats = await this.contracts.stats.getUserFullStats(address);
      
      return {
        isRegistered: Boolean(stats.isRegistered),
        sponsor: stats.sponsor || ethers.constants.AddressZero,
        maxLevel: Number(stats.maxLevel) || 0,
        quarterlyActive: Boolean(stats.quarterlyActive),
        marketingReferralBalance: stats.marketingReferralBalance || ethers.BigNumber.from(0),
        marketingMatrixBalance: stats.marketingMatrixBalance || ethers.BigNumber.from(0),
        quarterlyBalance: stats.quarterlyBalance || ethers.BigNumber.from(0),
        investmentBalance: stats.investmentBalance || ethers.BigNumber.from(0),
        leaderBalance: stats.leaderBalance || ethers.BigNumber.from(0),
        totalPendingBalance: stats.totalPendingBalance || ethers.BigNumber.from(0),
        totalInvested: stats.totalInvested || ethers.BigNumber.from(0),
        totalInvestmentReceived: stats.totalInvestmentReceived || ethers.BigNumber.from(0),
        investmentROI: stats.investmentROI || ethers.BigNumber.from(0)
      };
    } catch (error) {
      console.error('getUserFullStats error:', error);
      return null;
    }
  }

  /**
   * –û—Ç—Ä–∏–º–∞—Ç–∏ –±–∞–ª–∞–Ω—Å—ñ–≤ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
   */
  async getUserBalances(address) {
    try {
      const balances = await this.contracts.stats.getUserBalances(address);
      
      return {
        referralBalance: balances.referralBalance || ethers.BigNumber.from(0),
        matrixBalance: balances.matrixBalance || ethers.BigNumber.from(0),
        quarterlyBalance: balances.quarterlyBalance || ethers.BigNumber.from(0),
        investmentPending: balances.investmentPending || ethers.BigNumber.from(0),
        leaderBalance: balances.leaderBalance || ethers.BigNumber.from(0),
        totalBalance: balances.totalBalance || ethers.BigNumber.from(0)
      };
    } catch (error) {
      console.error('getUserBalances error:', error);
      return {
        referralBalance: ethers.BigNumber.from(0),
        matrixBalance: ethers.BigNumber.from(0),
        quarterlyBalance: ethers.BigNumber.from(0),
        investmentPending: ethers.BigNumber.from(0),
        leaderBalance: ethers.BigNumber.from(0),
        totalBalance: ethers.BigNumber.from(0)
      };
    }
  }

  /**
   * –û—Ç—Ä–∏–º–∞—Ç–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∫–≤–∞—Ä—Ç–∞–ª—å–Ω–æ—ó –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ
   */
  async getUserQuarterlyStats(address) {
    try {
      const stats = await this.contracts.stats.getUserQuarterlyStats(address);
      
      return {
        lastPayment: stats.lastPayment ? stats.lastPayment.toNumber() : 0,
        quarterCount: Number(stats.quarterCount) || 0,
        nextPaymentTime: stats.nextPaymentTime ? stats.nextPaymentTime.toNumber() : 0,
        isActive: Boolean(stats.isActive),
        charityAccount: stats.charityAccount || ethers.constants.AddressZero,
        techAccount1: stats.techAccount1 || ethers.constants.AddressZero,
        techAccount2: stats.techAccount2 || ethers.constants.AddressZero,
        uplineBalance: stats.uplineBalance || ethers.BigNumber.from(0)
      };
    } catch (error) {
      console.error('getUserQuarterlyStats error:', error);
      return {
        lastPayment: 0,
        quarterCount: 0,
        nextPaymentTime: 0,
        isActive: false,
        charityAccount: ethers.constants.AddressZero,
        techAccount1: ethers.constants.AddressZero,
        techAccount2: ethers.constants.AddressZero,
        uplineBalance: ethers.BigNumber.from(0)
      };
    }
  }

  /**
   * –û—Ç—Ä–∏–º–∞—Ç–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Å—Ç—Ä—É–∫—Ç—É—Ä–∏ (–ü–ê–†–¢–ù–ï–†–ò!)
   */
  async getUserStructureStats(address) {
    try {
      const stats = await this.contracts.stats.getUserStructureStats(address);
      
      return {
        directReferrals: Number(stats.directReferrals) || 0,
        referrals: stats.referrals || [],
        activeLevels: Number(stats.activeLevels) || 0,
        levelStatus: stats.levelStatus || []
      };
    } catch (error) {
      console.error('getUserStructureStats error:', error);
      return {
        directReferrals: 0,
        referrals: [],
        activeLevels: 0,
        levelStatus: []
      };
    }
  }

  /**
   * –û—Ç—Ä–∏–º–∞—Ç–∏ –≥–ª–æ–±–∞–ª—å–Ω—É —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
   */
  async getGlobalStats() {
    try {
      const stats = await this.contracts.stats.getGlobalStats();
      
      return {
        totalUsers: Number(stats.totalUsers) || 0,
        totalVolume: stats.totalVolume || ethers.BigNumber.from(0),
        investmentTotalInvestors: Number(stats.investmentTotalInvestors) || 0,
        investmentActiveInvestors: Number(stats.investmentActiveInvestors) || 0,
        investmentPoolBalance: stats.investmentPoolBalance || ethers.BigNumber.from(0),
        investmentTotalDistributed: stats.investmentTotalDistributed || ethers.BigNumber.from(0),
        leaderPoolTotalLeaders: Number(stats.leaderPoolTotalLeaders) || 0,
        leaderPoolActiveLeaders: Number(stats.leaderPoolActiveLeaders) || 0,
        leaderPoolBalance: stats.leaderPoolBalance || ethers.BigNumber.from(0),
        leaderPoolTotalDistributed: stats.leaderPoolTotalDistributed || ethers.BigNumber.from(0)
      };
    } catch (error) {
      console.error('getGlobalStats error:', error);
      throw error;
    }
  }

  // ==========================================
  // BRIDGE - –ü—Ä–æ–µ–∫—Ç–∏
  // ==========================================

  /**
   * –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –¥–æ—Å—Ç—É–ø –¥–æ –ø—Ä–æ–µ–∫—Ç—É
   */
  async checkUserAccess(projectId, userAddress) {
    try {
      return await this.contracts.bridge.checkUserAccess(projectId, userAddress);
    } catch (error) {
      console.error('checkUserAccess error:', error);
      return null;
    }
  }

  /**
   * –û—Ç—Ä–∏–º–∞—Ç–∏ —Å—Ç–∞—Ç—É—Å –¥–æ—Å—Ç—É–ø—É –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
   */
  async getUserAccessStatus(address) {
    try {
      return await this.contracts.bridge.getUserAccessStatus(address);
    } catch (error) {
      console.error('getUserAccessStatus error:', error);
      return null;
    }
  }

  /**
   * –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ –ø—Ä–æ–µ–∫—Ç–∏
   */
  async getAllProjects() {
    try {
      return await this.contracts.bridge.getAllProjects();
    } catch (error) {
      console.error('getAllProjects error:', error);
      return [];
    }
  }

  /**
   * –û—Ç—Ä–∏–º–∞—Ç–∏ –ø—Ä–æ–µ–∫—Ç
   */
  async getProject(projectId) {
    try {
      return await this.contracts.bridge.getProject(projectId);
    } catch (error) {
      console.error('getProject error:', error);
      return null;
    }
  }

  // ==========================================
  // EVENTS PARSING
  // ==========================================

  /**
   * –û—Ç—Ä–∏–º–∞—Ç–∏ —ñ—Å—Ç–æ—Ä—ñ—é –∞–∫—Ç–∏–≤–∞—Ü—ñ–π —Ä—ñ–≤–Ω—ñ–≤
   */
  async getLevelActivationsHistory(address) {
    try {
      const filter = this.contracts.globalWay.filters.LevelActivated(address);
      const events = await this.contracts.globalWay.queryFilter(filter);
      
      const history = [];
      for (const event of events) {
        const block = await event.getBlock();
        history.push({
          level: Number(event.args.level),
          timestamp: block.timestamp,
          blockNumber: event.blockNumber,
          txHash: event.transactionHash
        });
      }
      
      return history.sort((a, b) => b.timestamp - a.timestamp);
    } catch (error) {
      console.error('getLevelActivationsHistory error:', error);
      return [];
    }
  }

  /**
   * –û—Ç—Ä–∏–º–∞—Ç–∏ —ñ—Å—Ç–æ—Ä—ñ—é –∫–≤–∞—Ä—Ç–∞–ª—å–Ω–∏—Ö –ø–ª–∞—Ç–µ–∂—ñ–≤
   */
  async getQuarterlyPaymentsHistory(address) {
    try {
      const filter = this.contracts.quarterly.filters.QuarterlyPaid(address);
      const events = await this.contracts.quarterly.queryFilter(filter);
      
      const history = [];
      for (const event of events) {
        const block = await event.getBlock();
        history.push({
          quarter: Number(event.args.quarter),
          amount: event.args.amount,
          timestamp: block.timestamp,
          blockNumber: event.blockNumber,
          txHash: event.transactionHash
        });
      }
      
      return history.sort((a, b) => b.timestamp - a.timestamp);
    } catch (error) {
      console.error('getQuarterlyPaymentsHistory error:', error);
      return [];
    }
  }

  /**
   * –û—Ç—Ä–∏–º–∞—Ç–∏ –º–∞—Ç—Ä–∏—á–Ω—ñ –ø–æ–∑–∏—Ü—ñ—ó –¥–ª—è —Ä—ñ–≤–Ω—è
   * üî• –í–ò–ü–†–ê–í–õ–ï–ù–û: –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ LevelActivated –∑–∞–º—ñ—Å—Ç—å NewUserPlace
   */
  async getMatrixPositions(address, level) {
    try {
      const matrixInfo = await this.contracts.globalWay.getMatrixInfo(address, level);
      
      const positions = [];
      
      // üî• –í–ò–ü–†–ê–í–õ–ï–ù–û: –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –ø—Ä–∞–≤–∏–ª—å–Ω–∏–π —Ñ—ñ–ª—å—Ç—Ä
      const filter = this.contracts.globalWay.filters.LevelActivated(null, null, level);
      const events = await this.contracts.globalWay.queryFilter(filter);
      
      // –í—ñ–¥—Ñ—ñ–ª—å—Ç—Ä—É–≤–∞—Ç–∏ events –¥–ª—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
      const userEvents = events.filter(e => {
        const sponsor = e.args.sponsor;
        return sponsor && sponsor.toLowerCase() === address.toLowerCase();
      });
      
      // –°—Ç–≤–æ—Ä–∏—Ç–∏ map –ø–æ–∑–∏—Ü—ñ–π
      const positionMap = new Map();
      
      for (let i = 0; i < userEvents.length && i < 7; i++) {
        const event = userEvents[i];
        const user = event.args.user;
        const block = await event.getBlock();
        
        // –û—Ç—Ä–∏–º–∞—Ç–∏ ID –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
        const userInfo = await this.getUserInfo(user);
        
        positionMap.set(i, {
          position: i,
          user,
          userId: userInfo.id,
          placedBy: event.args.sponsor,
          timestamp: block.timestamp,
          isFilled: true
        });
      }
      
      // –ó–∞–ø–æ–≤–Ω–∏—Ç–∏ –≤—Å—ñ 7 –ø–æ–∑–∏—Ü—ñ–π
      for (let i = 0; i < 7; i++) {
        if (positionMap.has(i)) {
          positions.push(positionMap.get(i));
        } else {
          positions.push({
            position: i,
            user: ethers.constants.AddressZero,
            userId: '',
            placedBy: ethers.constants.AddressZero,
            timestamp: 0,
            isFilled: false
          });
        }
      }
      
      return {
        matrixInfo,
        positions
      };
    } catch (error) {
      console.error('getMatrixPositions error:', error);
      return {
        matrixInfo: null,
        positions: []
      };
    }
  }

  // ==========================================
  // ADMIN FUNCTIONS
  // ==========================================

  /**
   * –ë–µ–∑–∫–æ—à—Ç–æ–≤–Ω–∞ —Ä–µ—î—Å—Ç—Ä–∞—Ü—ñ—è
   */
  async freeRegister(address, sponsorAddress) {
    try {
      const tx = await this.contracts.globalWay.freeRegister(address, sponsorAddress, {
        gasLimit: CONFIG.GAS_LIMITS.adminAction
      });
      
      const receipt = await tx.wait();
      return receipt;
    } catch (error) {
      console.error('freeRegister error:', error);
      throw error;
    }
  }

  /**
   * –ó–∞–±–ª–æ–∫—É–≤–∞—Ç–∏ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
   */
  async blockUser(address, reason) {
    try {
      const tx = await this.contracts.globalWay.blockUser(address, reason, {
        gasLimit: CONFIG.GAS_LIMITS.adminAction
      });
      
      const receipt = await tx.wait();
      return receipt;
    } catch (error) {
      console.error('blockUser error:', error);
      throw error;
    }
  }
}

// –°—Ç–≤–æ—Ä–∏—Ç–∏ –≥–ª–æ–±–∞–ª—å–Ω–∏–π –µ–∫–∑–µ–º–ø–ª—è—Ä
const contracts = new ContractsManager();
